//
//  NetworkManager.swift
//  SwiftConcurrency
//
//  Created by Taekwon Lee on 12/19/23.
//

import UIKit

/* üìù GCD vs Swift Concurrency
 - completion handler
   - ÎπÑÎèôÍ∏∞Î•º ÎèôÍ∏∞Ï≤òÎüº
 - Thread Explosion
 - Context Switching
   -> ÏΩîÏñ¥Ïùò ÏàòÏôÄ Ïä§Î†àÎìúÏùò ÏàòÎ•º Í∞ôÍ≤å Ìï®
   -> Í∞ôÏùÄ Ïä§Î†àÎìú ÎÇ¥Ïóê continuation Ï†ÑÌôò ÌòïÏãùÏúºÎ°ú Î∞©ÏãùÏùÑ Î≥ÄÍ≤Ω
 
 - async throws / try await -> ÎπÑÎèôÍ∏∞Î•º ÎèôÍ∏∞Ï≤òÎüº ÏûëÎèô
 - Task: ÎπÑÎèôÍ∏∞ Ìï®ÏàòÏôÄ ÎèôÍ∏∞ Ìï®ÏàòÎ•º Ïó∞Í≤∞
 - async let : DispatchGroupÏôÄ Í∞ôÏùÄ Ïó≠Ìï†
 */

final class NetworkManager {
    
    //MARK: - Error
    enum NetworkError: Int, Error, LocalizedError {
        case unknown = 1
        case invalidData = 2
        case badRequest = 400
        case unauthorized = 401
        case permissionDenied = 403
        case serverError = 500
        
        var errorDescription: String {
            switch self {
            case .unknown:
                return "Ïïå Ïàò ÏóÜÏäµÎãàÎã§."
            case .invalidData:
                return "ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§."
            case .badRequest:
                return "ÏûòÎ™ªÎêú ÏöîÏ≤≠ÏûÖÎãàÎã§."
            case .unauthorized:
                return "Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥ Ï£ºÏÑ∏Ïöî"
            case .permissionDenied:
                return "Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§"
            case .serverError:
                return "ÏÑúÎ≤Ñ Ïò§Î•ò"
            }
        }
    }
    
    //MARK: - Singleton
    static let shared = NetworkManager()
    
    private init() { }
    
    //MARK: - Methods
    /// completion with UIImage
    func fetchThumbnail(completion: @escaping (UIImage) -> Void ) {
        let urlString = "https://an2-img.amz.wtchn.net/image/v2/y8zw23wQG88i2Y3lNWetpQ.jpg?jwt=ZXlKaGJHY2lPaUpJVXpJMU5pSjkuZXlKdmNIUnpJanBiSW1SZk5Ea3dlRGN3TUhFNE1DSmRMQ0p3SWpvaUwzWXlMM04wYjNKbEwybHRZV2RsTHpFMk9UazFPVEkwTmpnM016QTVNamd6TWpFaWZRLjFQU194eWZtVWFUZG5KUmhsY2V5RHVlVnZXVVhEQ2hhYlhnY01KZ1Fka1k"
        
        DispatchQueue.global().async {
            
            guard let url = URL(string: urlString) else { return }
            
            if let data = try? Data(contentsOf: url) {
                
                if let image = UIImage(data: data) {
                    DispatchQueue.main.async {
                        completion(image)
                    }
                }
            }
        }
    }
    
    /// completion with Result
    func fetchThumbnailURLSession(completion: @escaping ( Result<UIImage, NetworkError> ) -> Void ) {
        let urlString = "https://an2-img.amz.wtchn.net/image/v2/y8zw23wQG88i2Y3lNWetpQ.jpg?jwt=ZXlKaGJHY2lPaUpJVXpJMU5pSjkuZXlKdmNIUnpJanBiSW1SZk5Ea3dlRGN3TUhFNE1DSmRMQ0p3SWpvaUwzWXlMM04wYjNKbEwybHRZV2RsTHpFMk9UazFPVEkwTmpnM016QTVNamd6TWpFaWZRLjFQU194eWZtVWFUZG5KUmhsY2V5RHVlVnZXVVhEQ2hhYlhnY01KZ1Fka1k"
        
        guard let url = URL(string: urlString) else { return }
        
        let request = URLRequest( /// ÏöîÏ≤≠ÏùÑ Ìï† Îïå ÌÉÄÏù¥Î®∏, Ï∫êÏãú ÏÑ§Ï†ï Ïãú ÏÇ¨Ïö©
            url: url,
            cachePolicy: .useProtocolCachePolicy,
            timeoutInterval: 10
        )
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            
            guard error == nil else {
                completion(.failure(.unknown))
                return
            }
            
            guard let data else {
                completion(.failure(.invalidData))
                return
            }
            
            guard let response = response as? HTTPURLResponse,
                  response.statusCode == 200 else {
                completion(.failure(.invalidData))
                return
            }
            
            guard let image = UIImage(data: data) else {
                completion(.failure(.badRequest))
                return
            }
            
            completion(.success(image))
        }
        
        task.resume()
    }
    
    /// async await
    func fetchThumbnailAsyncAwait(urlString: String) async throws -> UIImage {
        /// async - ÎπÑÎèôÍ∏∞ÏûÑÏùÑ Î™ÖÏãú
        guard let url = URL(string: urlString) else {
            return UIImage()
        }
        
        /// ÏöîÏ≤≠ÏùÑ Ìï† Îïå ÌÉÄÏù¥Î®∏, Ï∫êÏãú ÏÑ§Ï†ï Ïãú ÏÇ¨Ïö©
        let request = URLRequest(
            url: url,
            cachePolicy: .useProtocolCachePolicy,
            timeoutInterval: 5
        )
        
        /// await - ÎπÑÎèôÍ∏∞Î•º ÎèôÍ∏∞Ï≤òÎüº Î≥¥Ïù¥ÎèÑÎ°ù ÏûëÏóÖ -> ÏùëÎãµÏù¥ Ïò¨ ÎïåÍπåÏßÄ Í∏∞Îã§Î¶º ‚≠êÔ∏è
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard (response as? HTTPURLResponse)?.statusCode == 200 else {
            throw NetworkError.badRequest
        }
        
        guard let image = UIImage(data: data) else {
            throw NetworkError.invalidData
        }
        
        return image
    }
    
    func fetchThumbnailAsyncLet() async throws -> [UIImage] {
        async let result1 = NetworkManager.shared.fetchThumbnailAsyncAwait(urlString: "https://www.themoviedb.org/t/p/w1280/sbgDVWrDxuUK7wHgpw8y9yMpIGD.jpg")
        async let result2 = NetworkManager.shared.fetchThumbnailAsyncAwait(urlString: "https://www.themoviedb.org/t/p/w1280/jpD6z9fgNe7OqsHoDeAWQWoULde.jpg")
        async let result3 = NetworkManager.shared.fetchThumbnailAsyncAwait(urlString: "https://www.themoviedb.org/t/p/w1280/318YNPBDdt4VU1nsJDdImGc8Gek.jpg")
        
        /// ÏÑ∏ Í∞ÄÏßÄÍ∞Ä Î™®Îëê Ïò¨ ÎïåÍπåÏßÄ Í∏∞Îã§Î¶º
        return try await [result1, result2, result3]
    }
}
